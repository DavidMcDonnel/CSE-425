Graded by: Chris Gill cdgill@wustl.edu
Score: 100/100 (95 + 5 extra credit)
Comments:

Good lab!

-1 Please put your names and the lab number at the top of your
ReadMe.txt file.  (please also remove all the extraneous text that was
generated by Visual Studio)

-1 Please use more descriptive labels than one and two for the first
and second argument indexes into argv.  For example, how about
input_file and output_file?

-3 Your scanner does not dynamically allocate number and label tokens
(and in fact by assigning them back to a token, the program slices off
the derived class portions).  I'd suggest using shared_ptr<Token> and allocating
using make_shared with the appropriate token class type.

The code compiled with no errors or warnings, and ran correctly in my tests.

========================================================================
    CONSOLE APPLICATION : lab1 Project Overview
========================================================================

AppWizard has created this lab1 application for you.

This file contains a summary of what you will find in each of the files that
make up your lab1 application.


lab1.vcxproj
    This is the main project file for VC++ projects generated using an Application Wizard.
    It contains information about the version of Visual C++ that generated the file, and
    information about the platforms, configurations, and project features selected with the
    Application Wizard.

lab1.vcxproj.filters
    This is the filters file for VC++ projects generated using an Application Wizard. 
    It contains information about the association between the files in your project 
    and the filters. This association is used in the IDE to show grouping of files with
    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
    "Source Files" filter).

lab1.cpp
    This is the main application source file.

/////////////////////////////////////////////////////////////////////////////
Other standard files:

StdAfx.h, StdAfx.cpp
    These files are used to build a precompiled header (PCH) file
    named lab1.pch and a precompiled types file named StdAfx.obj.

/////////////////////////////////////////////////////////////////////////////
Other notes:

AppWizard uses "TODO:" comments to indicate parts of the source code you
should add to or customize.

/////////////////////////////////////////////////////////////////////////////

Design:
	Abstract Representation: Symbol Table
	The representation we used to hold information on the Tokens seen in the first 
	recursive descent parser were lists of SymbolTableObjects. THe parsing function
	begins the recursive descent parser in the Scanner class which creates the 
	SymTabObjs for the labels and numbers in a valid HC. These objects hold a 
	shared_ptr to the seen Token and a vector of information
	about said Token. This information is relevant to the second recursive
	descent parser which is modeled after the output grammar.  THe Symbol Table has 
	a couple of vectors, but only the valid SymTabObjs are added to the 
	vector vsymsValid at the end of the rec dec parser. 
	These are the SymTabObjs that will go into the output of the parser function.

Implementation:
	Vector of Info enum for information on the shared_ptr to Token objects.
	Vector of valid SymTabObjs in the SymbolTable.
	Set of numbers seen and Set of labels, then converted to vector and then sorted. These 
	two are made for valid HCs in the parser function. 

	After a valid HC is made, we look at the Tokens in it in the parser and construct
	the numbers and labels sets from there.
	We then called a second recursive descent parser to create a string representing one
	good HC and send that out to the output file. This happens for each HC.
	Then we print out the contents of the set of numbers (default correctly sorted)
	and the contents of the set of labels (sent into a vector and then sorted in 
	alphabetic order with a custom string compare method). NOTE: The default sorting of a 
	set appears to be literally lexically sorted (upper case before lower case). 
	
In SymTabObj.cpp in the constructor, we were unable to make a shared pointer inside 
of a constructor call in the base initialization list, so we constructed that part 
of the SymTabObj inside of the constructor itself.
	
/////////////////////////////////////////////////////////////////////////////
Test Cases:

	1)
	Input:
	ancestor ( x , y ) :- parent ( x , z ) ^ ancestor ( z , y )
	solo ( HAN )
	solo ( HAN ) :- solo ( mio )
	friends ( Alice , BOB )
	notfriends ( bob , CharLIE )
	nogoodsyntax ( x , y ) nogoodsyntax ( x , z ) ^ nogoodsyntax ( z , y )
	badlyf0rm3dNAME ( x , y )
	goodname ( badlyf0rm3dARG )
	descendent ( 21 , 1 ) :- parent ( 3 , 21 ) ^ descendent ( 3 , 1 )
	solo ( 8115 )
	solo ( 8115 ) :- solo ( 1590 )
	friends ( 17 , 90 )
	notfriends ( 17 , 21 )
	extraA ( x , y ) ^ extraB ( z ) :- extraC ( z , x ) ^ extraD ( y ) ^ extraE ( x )
	extraF ( x , y ) ^ extraG ( z )

	Initial Output: (ignoring the sets of numbers abd labels for now)
 ( ( ancestor x y ) ( ( parent x z ) ( ancestor z y ) ) )
 ( ( solo HAN ) )
 ( ( solo HAN ) ( ( solo mio ) ) )
 ( ( friends Alice BOB ) )
 ( ( notfriends bob CharLIE ) )
 ( ( nogoodsyntax x y ) )
 ( ( nogoodsyntax x z ) )
 ( ( nogoodsyntax z y ) )
 ( ( x ) )
 ( ( solo 8115 ) )
 ( ( solo 8115 ) ( ( solo 1590 ) ) )
 ( ( friends 17 90 ) )
 ( ( notfriends 17 21 ) )
 ( ( extraA x y ) )
 ( ( extraB z ) ( ( extraC z x ) ( extraD y ) ( extraE x ) ) )
 ( ( extraF x y ) )
 ( ( extraG z ) )

	There was a bug in our code regarding a case where the Name was an invalid input
	or when the Args ws invalid. This caused the 2nd recursive descent parser to keep looking for a valid input,
	skipping the descendent line entirely to do so, and outputting an incorrect line.
	THe error was due to how we cleared the vector vsymsValid when we saw an invalid HC.

	Fixed Output:
	 ( ( ancestor x y ) ( ( parent x z ) ( ancestor z y ) ) )
	 ( ( solo HAN ) )
	 ( ( solo HAN ) ( ( solo mio ) ) )
	 ( ( friends Alice BOB ) )
	 ( ( notfriends bob CharLIE ) )
	 ( ( nogoodsyntax x y ) )
	 ( ( nogoodsyntax x z ) )
	 ( ( nogoodsyntax z y ) )
	 ( ( descendent 21 1 ) ( ( parent 3 21 ) ( descendent 3 1 ) ) )
	 ( ( solo 8115 ) )
	 ( ( solo 8115 ) ( ( solo 1590 ) ) )
	 ( ( friends 17 90 ) )
	 ( ( notfriends 17 21 ) )
	 ( ( extraA x y ) )
	 ( ( extraB z ) ( ( extraC z x ) ( extraD y ) ( extraE x ) ) )
	 ( ( extraF x y ) )
	 ( ( extraG z ) )


All other test cases were essentially the same as in the first lab, but with the differently 
formatted output. 
These tests were mainly ran without the Extra Credit code.

/////////////////////////////////////////////////////////////////////////////
Extra Credit:
If there are issues with the output, we suggest commenting out the areas of the code 
annotated in Scanner.ccp (lines 215-218) and RecDec2.cpp (lines 43-47), which are 
the Extra Credit portions of the assignment. The code has not been tested as thoroughly
with these additions as with the normal part of the lab, and some edge cases we did 
not catch with the extra credit code may pop up, but so far none have.

Design:
	We had to allow multiple predicates in the Head production of the input 
	and output grammars. 
Implementation: 
	We made a while loop looking for Ands in the first recursive descent parser
	(in Scanner.cpp) in the head() production. It then calls predicate() production
	to asess these other predicates.
	We used a similar setup in the 2nd recursive descent parser to include them in 
	the output.

Test Cases:
1)	Input:
	ancestor ( x , y ) :- parent ( x , z ) ^ ancestor ( z , y )
	solo ( HAN )
	solo ( HAN ) :- solo ( mio )
	friends ( Alice , BOB )
	notfriends ( bob , CharLIE )
	nogoodsyntax ( x , y ) nogoodsyntax ( x , z ) ^ nogoodsyntax ( z , y )
	badlyf0rm3dNAME ( x , y )
	goodname ( badlyf0rm3dARG )
	descendent ( 21 , 1 ) :- parent ( 3 , 21 ) ^ descendent ( 3 , 1 )
	solo ( 8115 )
	solo ( 8115 ) :- solo ( 1590 )
	friends ( 17 , 90 )
	notfriends ( 17 , 21 )
	extraA ( x , y ) ^ extraB ( z ) :- extraC ( z , x ) ^ extraD ( y ) ^ extraE ( x )
	extraF ( x , y ) ^ extraG ( z )

	Output:
	 ( ( ancestor x y ) ( ( parent x z ) ( ancestor z y ) ) )
	 ( ( solo HAN ) )
	 ( ( solo HAN ) ( ( solo mio ) ) )
	 ( ( friends Alice BOB ) )
	 ( ( notfriends bob CharLIE ) )
	 ( ( nogoodsyntax x y ) )
	 ( ( nogoodsyntax x z ) ( nogoodsyntax z y ) )
	 ( ( descendent 21 1 ) ( ( parent 3 21 ) ( descendent 3 1 ) ) )
	 ( ( solo 8115 ) )
	 ( ( solo 8115 ) ( ( solo 1590 ) ) )
	 ( ( friends 17 90 ) )
	 ( ( notfriends 17 21 ) )
	 ( ( extraA x y ) ( extraB z ) ( ( extraC z x ) ( extraD y ) ( extraE x ) ) )
	 ( ( extraF x y ) ( extraG z ) )
	Alice
	ancestor
	BOB
	bob
	CharLIE
	descendent
	extraA
	extraB
	extraC
	extraD
	extraE
	extraF
	extraG
	friends
	HAN
	mio
	nogoodsyntax
	notfriends
	parent
	solo
	x
	y
	z
	1
	3
	17
	21
	90
	1590
	8115

	This output differs from our Lab0 output in key areas, notably with the 
	'extra' lines and the last two nogoodsyntax lines. The extra credit catches 
	the ANDs between the head() productions and changes how we see the rest of the 
	lines. It reduces the total number of HCs because more grouping is allowed.

2) 
Input:
h ( ) :- n ( ) ^ k ( )
extraA ( x y ) ^ extraB ( c ) :- b ( )

Output:
 ( ( h ) ( ( n ) ( k ) ) )
 ( ( extraB c ) ( ( b ) ) )
b
c
extraB
h
k
n

This behaviour cuts out the invalid part of the second line, removing everything
already looked at up until the invalid argument input since there is no comma.
Then the scanner starts looking for the next start of a valid HC, which is a 
head() production. THe next time we see this is extraB. THis is interesting 
behaviour as it cuts out only the bad parts of a HC if it occurs in the beginning
of the HC, and there is another valid start for an HC to catch the scanner and 
look at the rest of the potential HC. 
It gives bad HCs a haircut and could make them into good HCs if there are two heads.

3)
Input:
h ( ) :- n ( ) ^ k ( )
extraA ( x , y ) ^ extraB ( c ) :- b ( )

Output:
 ( ( h ) ( ( n ) ( k ) ) )
 ( ( extraA x y ) ( extraB c ) ( ( b ) ) )
b
c
extraA
extraB
h
k
n
x
y


Expected behaviour. Everything here is a valid HC. 

4)
Input:
he ( v , b ) ^ w00rt ( bad ) :- je ( what )

Ouput:
 ( ( je what ) )
je
what

You can't give a haircut starting at the feet.
While we can have a bad first (previous) head() production and still see the 
rest of the HC, we can't do so with the last head() production being 
invalid. This causes the previous head() to be removed and itself 
to be removed. This makes the Scanner see the first label as
je, making it the head and 'what' its symbol.

/////////////////////////////////////////////////////////////////////////////
