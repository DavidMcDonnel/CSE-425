Graded by: Chris Gill cdgill@wustl.edu

Score: 85 / 100

Comments:

Lab solution was received within extension that was granted until 11:59pm on Thursday, September 17, 2015.

No deduction, but please only submit the files that were requested in the assignment, and not other files like stdafx.h etc. that were part of (or generated by) the Visual Studio project.

-3 Please avoid using hard coded numbers like 1, 2, or 3, and instead please use descriptively named const variables, enum labels, or #define symbols.

-3 Please make sure that each of your source and header files has at least a comment at the top with its purpose and your names.

-1 Please use the base/member initialization list instead of the body of the constructor to initialize member variables where possible.

The code compiled with no errors or warnings, and ran correctly in my tests except for:

-5 The program emitted an error message, but then crashed, when too few (or no) command line arguments were given.

-3 The program correctly excluded badlyf0rm3dNAME ( x , y ) as a badly formed predicate, but then took goodname ( badlyf0rm3dARG ) which
also was badly formed and incorrectly output goodname ( ).


/////////////////////////////////////////////////////////////////////////////



Lab0

Adam Sandor

David McDonnel



/////////////////////////////////////////////////////////////////////////////

Design:



We need a way to look at all the inputted valid terms. 



We also need a vector of Tokens where each token represents a valid token string.



Need to parse the input file strings until a valid HC token is read. 





///////////////////////////////////////////////////////////////////////////



Implementation:

We first make a vector of strings that holds all strings from the

input file.  

THen loop over this vector and make a vector of Token objects with 

the string and the Tokens enum. Invalid strings do not have a Token 

added to the vector<Token>



The parser is a recursive descent parser. These methods

refer to vt<Token> to parse. Starts with the method hc()

and has helper methods for the nonterminals and reads the terminals.

When the end of the hc() is reached, the method determines if the tokens

that have been looked at from vt[begin] to vt[counts] are a valid hc.

If so, return true, else false.

If invalid HC seen, erase the tokens looked at so far, and then looks at next.

Loops over the file input until no more to look at (in lab0.ccp parser method) 

so can handle multiple HC. 

Some exceptions are thrown in case the end of the file is reached or

if not a valid HC, or if end of file is reached but until the end of 

the file is a valid HC.





/////////////////////////////////////////////////////////////////////////////



Testing:

The precompile error registration broke so I would build every 3 lines 

of code or so to detect errors.

To test the parser, I made a few test input files with different valid 

and invalid HCs. And an output txt file, and I would see if the valid HCs were 

printed to the output file.



Test cases are included in attached test txt files.



test.txt:

	The entire file is a single valid HC. The output file has a single line of every

	string in the input file. 

	This behaviour is expected.



test1.txt:

	This file consists of 2 valid HCs. 

	The outputted file consists of 2 lines of text, each one is the individual

	valid HC. 

	This behaviour is expected. All valid HCs are seen and printed on separate lines.



test2.txt:

	This file consists of 1 well formed HC first, followed on the next line

	by an invalid HC.

	The output file consists of one line, which is the strings associated with the 

	one valid HC in the file. 

	This behaviour is expected, as it sees an invalid HC, then starts over (erases

	the tokens seen so far) and ends because there is nothing else in the file.

	The error print outs are a bit off from what we would like. They print out the

	error as it removes the invalid tokens one at a time, until it sees a valid start

	to a new HC. This may cause many errors to print to cout.



test3.txt:

	This file has an invalid HC and on the next line a valid HC.

	The output is a single line (the first line of the file) that has the

	strings associated with the valid HC. 

	This behaviour is expected. The parser saw an invalid token for a valid HC,

	and then erased all previous tokens (started over) and started looking for a 

	new valid HC.

	The error print outs are a bit off from what we would like. They print out the

	error as it removes the invalid tokens one at a time, until it sees a valid start

	to a new HC. This may cause many errors to print to cout.



test4.txt:

	This file has two valid HCs, and then two strings on the third line.

	The output is the two valid Hcs on different lines. 

	This behaviour is expected as it sees two separate HCs, prints them, and 

	then sees an invalid HC and does not print them.

	The error print outs are a bit off from what we would like. They print out the

	error as it removes the invalid tokens one at a time, until it sees a valid start

	to a new HC. This may cause many errors to print to cout.

	

test5.txt:

	This file consists of a valid HC, but all as one string without white space 

	between the valid Token strings.

	This makes sense as my inmplementation relies on the valid token strings to be

	separateed by white space.



test6.txt:

	This file consists of only And strings. There is nothing outputted to the

	output file, as expected. 





